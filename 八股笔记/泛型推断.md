为什么ArrayList<Integer> list = new ArrayList<>();后面的<>不用写泛型类型，但是使用mp时用到QueryWrapper<User> wrapper = new QueryWrapper<User>()时后面的<>需要写泛型？

钻石操作符的多个泛型对顺序有要求吗
**结论先行（一句话版）：**
> **有要求，而且是“严格有要求”**：  
> **钻石操作符 `<>` 中的泛型参数顺序，必须与类声明中的泛型参数顺序 _一一对应_，不能调换、不能省略、不能乱写。**

既然如此，上面提到的QueryWrapper问题为何不能根据左边的泛型自行推断右边的泛型

这是一个**非常好的“追根究底”的问题**，而且你已经抓到 Java 泛型里**最容易让人误解的核心点**了 👍  
下面我会**严格站在 Java 语言规范 + 编译器实现**的角度，解释：

> **为什么 `QueryWrapper<User> wrapper = new QueryWrapper<>();`  
> 编译器“看得见左边”，却依然不能推断右边的泛型**

---

## 一、先给最终结论（这一句最关键）

> **不是“不能看左边”，而是：  
> Java 8 的构造器泛型推断 _不会把左值的目标类型（target typing）完整地参与到复杂泛型构造器的推断中_**。

换句话说：

> **`new QueryWrapper<>()` 这个表达式在推断时，左边的 `QueryWrapper<User>` 并不会被当成“足够强的约束条件”。**

---

## 二、为什么你会觉得“理所当然能推断”？

因为在你心里，编译器可以这样想：

```java
QueryWrapper<User> wrapper = new QueryWrapper<>();
// 那不就是 new QueryWrapper<User>() 吗？
```

但 **Java 编译器实际不是这么工作的**。

---

## 三、Java 编译器是“先推右边，再看能不能赋给左边”

### 3.1 关键规则（JLS 中的真实流程）

在 Java 8 中：

1. **先对右侧表达式进行类型推断**
    
2. 推断出一个“具体类型”
    
3. 再检查这个类型 **是否可以赋值给左边**
    

⚠️ **左边不是“推断输入”，而是“校验目标”**

---

### 3.2 对比“方法调用”和“构造器调用”

#### 方法调用（推断能力强）

```java
static <T> T foo() { ... }

User u = foo();  // ✔ T = User
```

方法调用支持 **target typing**

---

#### 构造器调用（推断能力弱）

```java
QueryWrapper<User> w = new QueryWrapper<>();
```

这里的构造器：

- **不是泛型方法**
    
- 是一个“泛型类的构造器”
    
- Java 8 中推断规则更保守
    

---

## 四、为什么 ArrayList 可以，而 QueryWrapper 不行？（真正的分水岭）

### 4.1 ArrayList 是“单层、无约束”的泛型

```java
class ArrayList<E> {
    public ArrayList() {}
}
```

编译器在看到：

```java
List<Integer> list = new ArrayList<>();
```

时，可以做一个 **非常简单的替换**：

```text
E = Integer
```

没有歧义，也没有额外约束。

---

### 4.2 QueryWrapper 是“递归泛型 + 继承约束”

```java
class QueryWrapper<T>
  extends AbstractWrapper<T, String, QueryWrapper<T>> {}
```

而父类是：

```java
abstract class AbstractWrapper<
    T,
    R,
    Children extends AbstractWrapper<T, R, Children>
>
```

#### 编译器此时面对的是：

```text
T = ?
R = String
Children = QueryWrapper<T>
```

也就是说：

> **T 的取值，会反过来影响 Children 的定义**

这是一个 **递归约束系统**。

---

## 五、编译器为什么不“回头看左边”？（设计原因）

### 5.1 如果允许“回看左边”，会发生什么？

假设编译器这样做：

```text
左边是 QueryWrapper<User>
→ 推断右边 T = User
→ Children = QueryWrapper<User>
```

在这个例子里是 OK 的。

但在更复杂场景中，会出现：

```java
AbstractWrapper<User, ?, ?> w = new QueryWrapper<>();
```

此时：

- 左边是 **父类型**
    
- 信息不完整
    
- 可能推断出多个合法解
    

👉 **会引入歧义和不一致性**

---

### 5.2 Java 的选择：宁可保守，也不“猜”

Java 的设计哲学是：

> **“宁可让你多写一点，也不做可能错误的推断”**

所以：

- **构造器调用时**
    
- 对 **复杂泛型**
    
- **不完全依赖 target type**
    

---

## 六、这是 Java 8 的限制，不是 MP 的“锅”

事实上：

- Java 9 / 10 / 11 对 **diamond + 匿名类** 做过增强
    
- 但 **递归泛型 + 构造器** 这个问题，直到现在仍然是“显式写最稳妥”
    

所以 MP 官方文档、社区示例 **全部写成**：

```java
QueryWrapper<User> wrapper = new QueryWrapper<User>();
```

---

## 七、用一句“底层视角”的类比你就明白了

> **ArrayList 是“填空题”，QueryWrapper 是“联立方程组”。  
> Java 8 编译器只会解前者，不会自动解后者。**

---

## 八、一句话总结（可以直接复述）

> **`QueryWrapper` 之所以不能像 `ArrayList` 一样依赖左边泛型推断，是因为它涉及递归泛型和继承约束，而 Java 8 对构造器调用的类型推断采用“先推右值、后校验左值”的保守策略，不会将目标类型完整参与推断，从而避免歧义。**

---

如果你愿意，我可以继续帮你**从 JLS 角度**拆一个更“硬核”的问题：

👉 **为什么 Java 泛型必须类型擦除？如果不擦除，`QueryWrapper` 这种设计会简单多少？**

这个问题一旦想通，你对 Java 泛型的理解会直接拉到“语言设计层级”。